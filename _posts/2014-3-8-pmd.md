---
layout: post
title: 静态代码检查工具PMD
category: java
excerpt: 现在流行着很多静态代码分析工具，我曾经使用过findbugs、checkstyle以及PMD，其中关于pmd的使用，也有些体会。
tags: [test]
---
{% include JB/setup %}  

## PMD ##
作为一个游离在公司项目开发之外的人，近日boss交给我一个任务：代码清理。面对如此庞大的代码量，我觉得光靠肉眼是不能解决问题了，遂使用了比较流行的几个代码扫描工具。其中，在这里要说的是PMD。  
pmd的官方文档对于它的使用写的是非常清晰的。首先是最基本的使用方式：命令行。在Windows下，可以如此，`pmd -d c:\data\pmd\pmd\test-data\Unused1.java -f xml -R rulesets/java/unusedcode.xml`。如果你用了ant工具，则需要有一个正确的build.xml，格式大致如此，  

	<target name="pmd">
	 <taskdef name="pmd" classname="net.sourceforge.pmd.ant.PMDTask"/>
	 <pmd shortFilenames="true">
	  <sourceLanguage name="java" version="1.6"/>
	  <ruleset>rulesets/java/design.xml</ruleset>
	  <ruleset>java-basic</ruleset>
	  <formatter type="html" toFile="pmd_report.html">
	    <param name="linkPrefix" value="http://pmd.sourceforge.net/xref/"/>
	  </formatter>
	  <fileset dir="/usr/local/j2sdk1.4.1_01/src/">
	   <include name="java/lang/*.java"/>
	  </fileset>
	 </pmd>
	</target>
当然除了ant之外，将其作为maven的plugin也是可以的。  

	<reporting>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-pmd-plugin</artifactId>
				<configuration>
					<rulesets>
						<ruleset>/rulesets/braces.xml</ruleset>
						<ruleset>/rulesets/naming.xml</ruleset>
						<ruleset>d:\rulesets\strings.xml</ruleset>
						<ruleset>http://localhost/design.xml</ruleset>
					</rulesets>
				</configuration>
			</plugin>
		</plugins>
	</reporting>
不管是哪种形式，对于pmd而言，code path和rules是不可或缺的因素。前文中使用的“/rulesets/...”代表的其实是pmd默认的rule集合。通过组合、排除等手段，我们可以获得定制的规则集，这极大地方便了我们的工作。我经常使用的功能，包括了unused code，unnecessary code，design和duplicate code这些。其中duplicate code的扫描，经常是个很费劲的过程。因为pmd设计成了一个内存消耗型的工具，经常需要我们手动设置更大的VM内存，它的使用方法是`java -Xmx512m net.sourceforge.pmd.cpd.CPD --minimum-tokens 100 --files /usr/local/java/src/java`，cpd是其子工具，在pmd home的bin目录下可以看到。  
### pmd rule ###
可是如果你不满足于pmd内置的这些检查规则，pmd强大的可定制化便了用武之地。在pmd的文档中提到了2种方式做扩展：java和xpath。在研究之前，我们可以先试试看designer.bat工具。
<img src = "{{ ASSET_PATH }}/images/pmd_1.jpg"/>
这个工具能比较清晰地让我们快速了解pmd的代码扫描策略。<div color="red">PMD doesn't use the source code directly; it uses a JavaCC generated parser to parse the source code and produce an AST (Abstract Syntax Tree).</div>这是pmd文档的原话，pmd实际使用了javaCC来给java source code做语法分析。

	public class WhileLoopsMustUseBracesRule extends AbstractJavaRule {
	    public Object visit(ASTWhileStatement node, Object data) {
	        Node firstStmt = node.jjtGetChild(1);
	        if (!hasBlockAsFirstChild(firstStmt)) {
	            addViolation(data, node);
	        }
	        return super.visit(node,data);
	    }
	    private boolean hasBlockAsFirstChild(Node node) {
	        return (node.jjtGetNumChildren() != 0 && (node.jjtGetChild(0) instanceof ASTBlock));
	    }
	}
这段代码在遇到ASTWhileStatement这个元素时，便会进入我们的code。`node.jjtGetNumChildren() != 0 && (node.jjtGetChild(0) instanceof ASTBlock)`做了一个判断，判断ASTWhileStatement是否有child，并且第一个应该是一个ASTBlock。`addViolation(data, node)`帮我们将这个代码的信息添加到了violation中去。如果想知道，stetement在pmd中是如何定义的，可以查询pmd的代码<b>pmd/etc/grammar/Java.jjt</b>，这里包含了其他一些source文件的语法单元定义。
<img src = "{{ ASSET_PATH }}/images/pmd_2.jpg"/>
在完成代码的编写之后，就是将其加入到某个rule.xml中，方便我们以后的调用。

	<rule name="WhileLoopsMustUseBracesRule"
          message="Avoid using 'while' statements without curly braces"
		  class="WhileLoopsMustUseBracesRule">
		<description>
    	  Avoid using 'while' statements without using curly braces
    	</description>
	</rule>
在这里并没有对pmd代码过多的分析，主要讲讲怎么用的舒服。目前，我对它也没有特别深入的了解（Code级别和设计级别），以后有时间在欣赏它的实现好了。
### 结束语 ###
###### 现代的编程开发好比建造摩天大楼，一个项目很容易就达到千万行的级别。而当我们的项目变得庞大时，代码的质量就会不断下降。如果底层的代码出现了问题，就好比是大楼的地基松动了。如果不及时修复，扩展会变得极其危险。而为了解决旧有代码的问题，我们经常会做出一些尝试，第一个自然是重构；还有另一个，便是本文所提到的，代码检查。而每当使用这类代码检查工具时，总能发现一点bug（如果你还没用过，应该选择一个试一试^^）。当然代码检查工具无论何时都无法代替代码调试以及测试。它只是在你完成了测试工作之后的一个锦上添花，专业的测试还是需要进行的。######