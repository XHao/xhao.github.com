---
layout: post
title: 接触maven
category: maven
excerpt: 由于公司项目需要使用maven作为build工具，我take了转化的工作。虽然了解maven，但鉴于项目的庞大以及诸多不符合maven规范的地方，所以转化起来也很麻烦。
tags: [学习笔记]
---
{% include JB/setup %}

首先声明，我支持正版书籍，抵制盗版。不过我还是分享一下<a href="http://www.ppurl.com/2013/02/maven%e5%ae%9e%e6%88%98.html" title="据说是永久链接，各位看官自便">Maven实战</a>，知识的分享，是独乐乐不如众乐乐！  
Maven最大的优势在于简单，提高了项目发布的速度，最大的劣势在于文档缺乏或者说查询不便利。
##  构建
对于刚开始使用的人来说，maven最重要的用途就是构建了。“mvn clean install”——这个最简单的maven命令就能帮助工程师完成繁琐的构建工作。Maven的构建有一些重要的定义，比如生命周期（Lifecycle）。对于一个传统的项目而言，它实施构建的主要步骤是相似的，而把这套流程抽象出来，就可以视为我们所说的生命周期。在Maven中，生命周期只是一个概念，并没有赋予他们什么实际的工作。一个生命周期通常又会有许多构建阶段组成（build phase）。比如maven中default lifecycle = vaidate ... -> ... deploy。每当使用mvn deploy时，实际会从validate执行到deploy，也就是我们只需要选择最后一个阶段即可。生命周期没有完成的任务其实都是交由插件：目标来完成的。maven的这种松耦合的设计非常利于扩展，实际上maven只是定义了在构建阶段应该做的事以及它们的顺序，但并没有强制你怎么做（maven有一套默认的插件：目标）。用一张图大概就能描述清楚
<img src = "{{ ASSET_PATH }}/images/maven_01.jpg"/>  
真正和project打交道的是插件，所以它也能独立于phase来执行。所以如何执行，就在于你如何绑定build phase和plugin:goal，它们之间其实是多对多的关系。如果是`mvn clean dependency:list package`，实际上就是phase和plugin的糅合。  
maven中package也会影响到构建的过程，这是因为maven支持多种打包类型，比如jar、war、pom等。不同的打包类型实际决定了phase和plugin的绑定关系。    

	...
	 <plugin>
	   <groupId>com.mycompany.example</groupId>
	   <artifactId>display-maven-plugin</artifactId>
	   <version>1.0</version>
	   <executions>
	     <execution>
	       <phase>process-test-resources</phase>
	       <goals>
	         <goal>time</goal>
	       </goals>
	     </execution>
	   </executions>
	 </plugin>
	...
这是maven官网上的sample。刚开始用maven会觉得很难用，可能是对插件的不熟悉，实际感觉maven的架构是很flexible的。  
注：为什么plugin:goal和phase绑定就完事了呢？那是因为maven虽然提供了3个生命周期（clean、default、site），但是它们是互相独立的，phase指的就是某个特定的lifecycle。如何设计自己的lifecycle和phase，这个我还不清楚，这方面涉及不多。=。=
## 传递依赖
maven还有一个重要的特点是提供了repository仓库，这个由许多项目构成的仓库。通过坐标，maven会适时地下载所对应的工程，帮助我们解决项目的依赖问题。有时候，我们也可以使用Maven Dependency Plugin来查看当前项目的依赖关系。比如`mvn dependency:list`：Displays the list of dependencies for this project。为了实现maven的易用性，maven有自己的依赖调节机制，这是为了防止重复依赖的出现（项目多的时候就会出现，如果开发者不能理清每个项目的依赖的话）。maven提供了2条原则去遵守：1.路径短最优；2.声明先最优。  
我在用的时候，经常会发现war包的lib中出现了部分，我没有主动定义的jar包，这些都是传递依赖造成的。本来呢，它简化了项目的依赖管理，但是有时候却给我带来了不必要的麻烦——引入了多余的jar。这在编译的过程中或许不会带来什么问题，因为在打包过程中，maven能够解决项目之间复杂的依赖关系，保证项目的构建成功，但是运行时却未必。比如在tomcat中使用的时候，出现了`A->B->C1,D->E->C2`这种情况，C1与C2恰巧是一个项目的不同版本，在加载过程中，就会引发冲突。唉，这其实是把双刃剑！当然，maven中是可以通过exclusions的方式拒绝传递依赖，并特别指出本项目中应该使用的jar包。
## 反应堆
maven使用的配置文件叫pom，project object model，所以它和软件开发一样，也有聚合、继承这类概念，也可以优化。对于一个多模块的项目而言，反应堆（reactor）指的是所有模块组成的一个构建结构。

	<modules>
		<module>A</module>
		<module>B</module>
		<module>C</module>
		<module>D</module>
	</modules>
图中A、B、C、D就构成了一个构建模块，它的含义不仅仅是代表了需要构建这4个模块，同时还需要遵循他们的依赖关系，比如A->D->C->B。maven会构造出一个有向非循环图，只有这样的依赖关系才能保证构建的正确性。反应堆不是绝对的，因为在实际的构建过程中，我们可以通过命令来裁剪这个构建堆，比如`mvn install -pl C 	-am`，这时除了B之外的模块我们都会构建，具体的参数去maven的网站上查询就知道了。
### 小结
在初级的实践中，大部分力气都花在了解决依赖和如何打包上。因为实际项目比较庞大，模块相当之多，且完全没有按照maven的约定，这都增加了使用的麻烦程度。选择好的maven插件往往是一条捷径，尤其是我现在正处理的项目有140+的模块，并且打包之后，还要支持第三方的客户化开发。